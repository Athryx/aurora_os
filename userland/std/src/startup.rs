use core::{slice, arch::asm};

extern "C" {
    fn main();
}

// This is the function marked as the entrypoint by the linker
#[naked]
#[no_mangle]
pub extern "C" fn _aurora_startup() {
    unsafe {
        asm!(
            "pop rdi", // process data pointer
            "pop rsi", // process data size
            "pop rdx", // startup data pointer
            "pop rcx", // startup data size
            "call _rust_startup",
            options(noreturn)
        )
    }
}

#[no_mangle]
pub extern "C" fn _rust_startup(
    process_data: *mut u8,
    process_data_size: usize,
    namespace_data: *mut u8,
    namespace_data_size: usize,
) -> ! {
    let process_data = unsafe {
        slice::from_raw_parts(process_data, process_data_size)
    };

    let (process_init_data, memory_entries) = aurora_core::process_data_from_slice(process_data)
        .expect("invalid process data array passed into program");

    aurora_core::init_allocation(process_init_data, memory_entries)
        .expect("failed to initialize aurora lib allocaror");

    let namespace_data = unsafe {
        slice::from_raw_parts(namespace_data, namespace_data_size)
    };

    aurora::env::init_namespace(namespace_data)
        .expect("failed to initialize aurora library");

    unsafe {
        // main is function generated by rust compiler which calls the start lang item
        // it is used only to resolve actual rust main method, it does not perform any other startup actions
        main();
    }

    aurora::thread::exit();
}

#[lang = "start"]
fn lang_start<T: 'static>(main: fn() -> T, _argc: isize, _argv: *const *const u8, _sigpipe: u8) -> isize {
    main();

    0
}